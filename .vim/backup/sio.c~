#include "sio.h"
#include <Cpu/Std/IfxCpu.h>

static uint8_t  sio_rx_buffer[128]; // NOT USED


/*
 *  Handles an Transmit Interrupt for given SIO Module.
 * */
void sio_transmit_handler(volatile SIO_Module* sio_module)
{
	volatile sio_interrupt_struct *interrupt_struct = &sio_module->interrupt_struct; /*Get Pointer to interrupt Struct*/
	SIO_coding_sheme coding_sheme = sio_module->coding_sheme;
	lemdd_io_level_e level = LEMDD_IO_LOW;											 /*Level to set at Out Pin.*/
	uint8_t setPin = 0;
	switch(interrupt_struct->txBitPos)
	{
		// Send Start Bit First:
		case(sio_bitPosition_START):
		{
			if (SIO_coding_sheme_MANCHESTER_FALLING_EDGE == coding_sheme)
			{
				level = LEMDD_IO_HIGH;
			}
			else if ((SIO_coding_sheme_MANCHESTER_RISING_EDGE == coding_sheme))
			{
				level = LEMDD_IO_LOW;
			}
			if (interrupt_struct->bit_sendIR == 0)
			{
				interrupt_struct->bit_sendIR++;
				setPin = 1;
			}
			else if (interrupt_struct->bit_sendIR == 1)
			{
				interrupt_struct->bit_sendIR = 0;
				interrupt_struct->txBitPos = sio_bitPosition_1;
				setPin = 1;
				level = (level == LEMDD_IO_HIGH) ? LEMDD_IO_LOW : LEMDD_IO_HIGH;
			}
			break;
		}
		case(sio_bitPosition_1):
		case(sio_bitPosition_2):
		case(sio_bitPosition_3):
		case(sio_bitPosition_4):
		case(sio_bitPosition_5):
		case(sio_bitPosition_6):
		case(sio_bitPosition_7):
		case(sio_bitPosition_8):
		{
			/*Get the bit to be transmitted out of the Byte to be transmitted according to current bitposition*/
			uint8_t txBit =
					((interrupt_struct->txByte) >> (8 - interrupt_struct->txBitPos))
					& 0x1;

			if (((SIO_coding_sheme_MANCHESTER_FALLING_EDGE == coding_sheme)
					&& (txBit == 1)) /*In this case we want a falling edge to indicate a 1*/
				||

				((SIO_coding_sheme_MANCHESTER_RISING_EDGE == coding_sheme)
					&& (txBit == 0))) /*In this case we want a falling edge to indicate a 0*/
			{
				//We need a Falling Edge
				level = LEMDD_IO_HIGH;
				setPin = 1;
			}
			else if ( 	((SIO_coding_sheme_MANCHESTER_FALLING_EDGE == coding_sheme)
							&& (txBit == 0)) /* In this case we want a Rising Edge to indicate a 0*/
					||
						((SIO_coding_sheme_MANCHESTER_RISING_EDGE == coding_sheme)
							&& (txBit == 1))) /*In this case we want a Rising Edge to indicate a 1*/
			{
				//We need a Rising Edge
				level = LEMDD_IO_LOW;
				setPin = 1;
			}
			else
			{
				setPin = 0;
				//Should never happen.
			}
			if (interrupt_struct->bit_sendIR == 0 && setPin)
				{
					interrupt_struct->bit_sendIR++;
				}
			else if (interrupt_struct->bit_sendIR == 1 && setPin)
			{
				interrupt_struct->bit_sendIR = 0;
				interrupt_struct->txBitPos++; /*increment to next Bit.*/
				//Invert level to set, because we are in second interrupt for this bit.
				level = (level == LEMDD_IO_HIGH) ? LEMDD_IO_LOW : LEMDD_IO_HIGH;
			}
			else
			{
				//Should be impossible to reach.
			}
			break;
		}/*from case sio_bitPosition_8*/

		case (sio_bitPosition_LOWPHASE):
		{/*We need to set pin to 0 for at least one bit time.*/
			if ( interrupt_struct->bit_sendIR < 2)
			{
				setPin = 1;
				level = LEMDD_IO_LOW;
				interrupt_struct->bit_sendIR++;
			}
			else if (interrupt_struct->bit_sendIR == 2)
			{
				/*We are done*/
				setPin = 1;
				level = LEMDD_IO_LOW;
				interrupt_struct->bit_sendIR = 0;
				interrupt_struct->txBitPos = sio_bitPosition_FINISHED; /*Indicate transmission complete !*/
				/*Disable Transmission handler for now.*/
				interrupt_struct->isr_mode.raw &= ~sio_interrupt_mode_TRANSMIT;
			}
			else
			{
				setPin = 0;
				// Should never happen.
			}
			break;
		}
		case (sio_bitPosition_FINISHED):
		{
			/*Do nothing here*/
			setPin = 0;
			break;
		}

	}
	if (1 == setPin)
	{/*If any case said we should set pin level do so.*/
		lemdd_io_set_output_level(sio_module->io_pin,level);
	}
}



/*NOT IMPLEMENTED NOT TESTED*/
uint8_t sio_buffer_readBit(uint8_t *buff, uint16_t index)
{
	return 0;
	//TODO: Implement ?
}

uint8_t sio_checkIfLowPhase(volatile SIO_Module *sio_module)
{
	return 0;
	//TODO: Implement ?
}


//Decodes Bitbuffer after detection of low phase
//WARNING: CODE NOT TESTET AND NOT FINISHED !
void sio_receive_decode(volatile SIO_Module *sio_module)
{
	//TODO: Implement ?
}

//WARNING: CODE NOT TESTET AND NOT FINISHED !
void sio_receive_handler(volatile SIO_Module *sio_module)
{

	//TODO: Implement ?
}

void sio_interrupt_handler(SIO_Module *sio_module)
{
	if (!(sio_interrupt_mode_IGNORE == sio_module->interrupt_struct.isr_mode.raw))
	{

		uint8_t interruptNum 		= sio_module->interrupt_struct.isr_counter;
		uint8_t bitTime 			= sio_module->bitTime;
		uint8_t timerPeriod 		= sio_module->timerPeriod;
		uint8_t interruptsPerBit   	= bitTime/timerPeriod;
		//The timer may run faster than required.
		//sendInterruptValid makes sure, that tx interrupt gets only called twice per bitTime
		//Caution: timerPeriod and interruptsPerBit must be dividable by 2
		uint8_t sendInterruptValid  = (0 == (interruptNum % (interruptsPerBit/2 + interruptsPerBit%2)));



		if (sio_interrupt_mode_RECEIVE & sio_module->interrupt_struct.isr_mode.raw)
		{
			// Handle receive
			//TODO:sio_receive_handler(sio_module);
		}
		if (sio_interrupt_mode_TRANSMIT & sio_module->interrupt_struct.isr_mode.raw)
		{
			// handle transmit
			sio_module->interrupt_struct.isr_counter++;
			if (sendInterruptValid)
			{
				sio_transmit_handler(sio_module);
			}
		}
	}
	else
	{
		//Stop Timer.
		sio_module->interrupt_struct.isr_counter = 0;
		IfxStdIf_Timer_stop(sio_module->timer);
	}
}


void SIO_transmitByte(SIO_Module *module,uint8_t byte)

{
	volatile sio_interrupt_struct *interrupt_struct = &module->interrupt_struct;
	interrupt_struct->isr_counter = 0;
	interrupt_struct->txByte = byte;								/*Set byte to be transmitted*/
	interrupt_struct->txBitPos = sio_bitPosition_START;				/*Set bitpos to start bit*/
	interrupt_struct->bit_sendIR = 0;								/*Set sendIr to bit beginning (0)*/
	interrupt_struct->isr_mode.raw  |= sio_interrupt_mode_TRANSMIT; /*Enable TX Handler*/
	IfxStdIf_Timer_run(module->timer);								/*Start interrupt timer*/
	volatile uint8_t counter = 0;
	while(interrupt_struct->txBitPos != sio_bitPosition_FINISHED) /*Block till interrupt finishes*/
		counter++;
}

void SIO_init(SIO_Module *module, lemdd_io_pin_s* io_pin,IfxStdIf_Timer *timer,SIO_coding_sheme sheme, uint8_t bitTime,uint8_t timerPeriod)
{
	module->io_pin 									= io_pin;
	module->timer  									= timer;
	module->coding_sheme 							= sheme;
	module->bitTime									= bitTime;
	module->timerPeriod								= timerPeriod;

	module->interrupt_struct.isr_counter			= 0;
	module->interrupt_struct.txBitPos 				= sio_bitPosition_START;
	module->interrupt_struct.rxBitPos				= sio_bitPosition_START;
	module->interrupt_struct.bit_sendIR 			= 0;
	module->interrupt_struct.txByte 				= 0x00;
	module->interrupt_struct.isr_mode.e 			= sio_interrupt_mode_IGNORE;
	module->interrupt_struct.rx_buf 				= 0;
	module->interrupt_struct.rx_bufLen				= 0;
	module->interrupt_struct.rx_bufPos				= 0;
}
//WARNING: CODE NOT TESTET AND NOT FINISHED !
void SIO_beginReceive(SIO_Module *module)
{
	//TODO: Implement ?
}

//WARNING: CODE NOT TESTET AND NOT FINISHED !
void SIO_receiveByte(SIO_Module *module,uint8_t *byte)
{

	//TODO: Implement ?
}


//WARNING: CODE NOT TESTET AND NOT FINISHED !
uint8_t SIO_TryendReceive(SIO_Module *module, uint8_t *byte)
{
	return 0;
	//TODO: Implement ?
}

