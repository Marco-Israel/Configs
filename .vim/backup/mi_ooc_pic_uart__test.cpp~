
/**
 * @file 	mi_ooc_pic_uart__test.cpp
 * @author 	Marco Isarel (MI)
 * @date 	2019-06
 * @ingroup cppUTest
 * @copyright Copyright (c) 2019 Marco Israel
 *
 *
 * @brief Test the mi_ooc pic object
 *
 *
 * @details ooc software interface only test
*/


#include "CppUTest/TestHarness.h"



extern "C" {
#include <xc.h>
#include <uart1.h>
#include <pin_manager.h>
#include <mi_ooc_uartwrapper.h>
#include <spy.h>
#include <pic_uart.h>
}



#define HWNR  (1u)

pic_uart__this__st picUART1__S = {};
pic_uart__ctorParamList__st picUART1_paramList__S = {};


//uart__this__st UART1__S = {};
//uart__ctorParamList__st UART1_paramList__S = {};
//
TEST_GROUP(MI_OOC_PIC_UART_TG)
{
    void setup()
    {
        UART1_Initialize();

        picUART1_paramList__S.baseParamList__S.attribute__S.hwNr = HWNR;
    //    UART1_paramList__S.attribute__S.hwNr = HWNR;

        pic_uart__new(&picUART1__S, &picUART1_paramList__S);
//        uart__new(&UART1__S, &UART1_paramList__S);

        UART1_reset_SPY();

    }

    void teardown()
    {
    }



};



TEST(MI_OOC_PIC_UART_TG, 1__is_the_hwNr_initialized)
{
    LONGS_EQUAL(HWNR, picUART1__S.base__S.attribute__S.hwNr);
}



TEST(MI_OOC_PIC_UART_TG, 2__is_UART_enabeld){


    LONGS_EQUAL(1, U1CON1bits.ON);
    LONGS_EQUAL(1, U1CON0bits.TXEN);

    U1CON1bits.ON = 0;
    U1CON0bits.TXEN = 0;

    _uart1__enable_tx_if_not();

    LONGS_EQUAL(1, U1CON1bits.ON);
    LONGS_EQUAL(0, U1CON0bits.TXEN);
}



TEST(MI_OOC_PIC_UART_TG, 3__is_tX_ready_to_send)
{

    uint8_t tx_bufferFull = 0;
    uint8_t tx_writeError = 0;
    uint8_t tx_enabeld = 1;
    uint8_t tx_enabeld_and_bufferEmpty = 1;

    CHECK_EQUAL(tx_bufferFull, U1FIFObits.TXBF);
    CHECK_EQUAL(tx_writeError, U1FIFObits.TXWRE);
    CHECK_EQUAL(tx_enabeld, U1CON0bits.TXEN);
    CHECK_EQUAL(tx_enabeld_and_bufferEmpty, PIR3bits.U1TXIF);

    CHECK_EQUAL(TRUE, _uart1__is_tx_ready() );
}



TEST(MI_OOC_PIC_UART_TG, 4__check_tx_for_error_flags)
{
    CHECK_EQUAL(0u, _uart1__tx_has_error() );
    U1FIFO = 0xFF;
    CHECK_EQUAL(1u, _uart1__tx_has_error() );
}

TEST(MI_OOC_PIC_UART_TG, 5__clear_tx_error_flag)
{

    U1FIFO = 0xFF;
    CHECK_EQUAL(1, U1FIFObits.TXWRE);
    _uart1__clear_tx_error_statusflag();
    CHECK_EQUAL(0, U1FIFObits.TXWRE);


}




TEST(MI_OOC_PIC_UART_TG, 6__one_byte_written_to_TSR_send_shift_register)
{

    uint8_t interruptFlag = 1;
    uint8_t valueToSend[1] = {0xAA};

    PIR3bits.U1TXIF = (0x1 & interruptFlag);
    pic_uart__send(&picUART1__S, &valueToSend[0], 1u);
    LONGS_EQUAL(0xAA, U1TXB);

}


TEST(MI_OOC_PIC_UART_TG, 7__multi_byte_write_to_TSR_send_shift_register)
{
    uint8_t interruptFlag = 1;
    PIR3bits.U1TXIF = (0x1 & interruptFlag);

    uint8_t valueToSend[4] = {0xDE,0xAD, 0xBE, 0xEF};



    CHECK_EQUAL(4, pic_uart__send(
                &picUART1__S, &valueToSend[0], sizeof(valueToSend) ) );


    CHECK_EQUAL(4, _g__uart1TX_timesCalled);
    MEMCMP_EQUAL(&valueToSend[0], _g__uart1_TSR, sizeof(valueToSend) );

}


TEST(MI_OOC_PIC_UART_TG, 8__only_some_bytes_of_buffer_write)
{

    uint8_t interruptFlag = 1;
    PIR3bits.U1TXIF = (0x1 & interruptFlag);
    uint8_t valueToSend[4] = {0xDE,0xAD, 0xBE, 0xEF};

    CHECK_EQUAL(2, pic_uart__send(
                &picUART1__S, &valueToSend[0], 2u ) );
    CHECK_EQUAL(2, _g__uart1TX_timesCalled);

    uint32_t tmp_compareValue = 0x0000ADDE;
    MEMCMP_EQUAL(&tmp_compareValue, _g__uart1_TSR, sizeof(valueToSend) );

}



TEST(MI_OOC_PIC_UART_TG, 9__uart_mode_get_set)
{
    uint8_t asynchronous8BitMode_noParity = 0x00;
    LONGS_EQUAL(asynchronous8BitMode_noParity, U1CON0bits.MODE);
}



TEST(MI_OOC_PIC_UART_TG, 10__baudrate_get_set)
{
    uint8_t highRegPeriodOfBaudrateTimer  = 0x00;
    uint8_t lowRegPeriodOfBaudrateTimer  = 0x8A;

    LONGS_EQUAL(highRegPeriodOfBaudrateTimer, U1BRGH);
    LONGS_EQUAL(lowRegPeriodOfBaudrateTimer, U1BRGL);
}



TEST(MI_OOC_PIC_UART_TG, 11__baudrate_multiplier_ge_set)
{
    uint8_t baudrateTimerMultiplier = 0x00;
    LONGS_EQUAL(baudrateTimerMultiplier, U1BRGS);
}



TEST(MI_OOC_PIC_UART_TG, 12__PORTB_PIN2_is_configuard_as_uart_TX_OUTPUT)
{
    uint8_t pinFunctionToUartTx = 0x13;
    uint8_t pinTXAsOutput = (0u<<2);

    PIN_MANAGER_Initialize();

    LONGS_EQUAL(pinFunctionToUartTx, RB2PPS);
    LONGS_EQUAL(pinTXAsOutput, TRISBbits.TRISB2);
}

TEST(MI_OOC_PIC_UART_TG, 13__mock_a_call_to_TX_error_handler)
{

}


TEST(MI_OOC_PIC_UART_TG, 14__watch_for_enabeld_tx_or_uart_interrups)
{
    uint8_t generalInterruptsActiveAndFlagSet = 0x00;/* Wakeup and AutoBaud) */
    LONGS_EQUAL(generalInterruptsActiveAndFlagSet, U1UIR);



    uint8_t generalERRORInterruptsActive = 0x00;
    uint8_t generalERRORInterruptFlagsSet= 0x00;
    LONGS_EQUAL(generalERRORInterruptsActive, U1ERRIE);
    LONGS_EQUAL(generalERRORInterruptFlagsSet, U1ERRIR);



    uint8_t txShiftRegisterEmptyInterruptActive = 0x00;
    uint8_t txShiftRegisterEmptyFlagSet = 0x00;
    LONGS_EQUAL(txShiftRegisterEmptyInterruptActive, U1ERRIEbits.TXMTIE);
    LONGS_EQUAL(txShiftRegisterEmptyFlagSet, U1ERRIRbits.TXMTIF);
}

