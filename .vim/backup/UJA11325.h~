/*
 * UJA11325.h
 *
 *  Created on: 27.05.2019
 *      Author: Z602900
 *
 *
 * This header defines a driver for the UJA113x System Basis Chip.
 *
 * This driver needs an initialized and working SPI Channel to function.
 *
 * All SPI relevant methods are platform specific. U need to implement them if you want to
 * port this driver.
 * Platform specific functions are located inside UJA11325_Transceive.h
 *
 *
 *
 */

#ifndef CDRV_UJA11325_UJA11325_H_
#define CDRV_UJA11325_UJA11325_H_

#include "lemdd_header.h"
#include "UJA11325_Transceive.h"

#define UJA113X_WD_CTRL_WMC_MSK 			(0xE0)	/*WMC Bit Mask for Watchdog Control Register*/
#define UJA113X_WD_CTRL_NWP_MSK 			(0x0F)	/*NWP Bit Mask for Watchdog Control Register*/
#define UHA113x_MODE_CTRL_MC_MSK			(0x7)	/*Mask for MC Bits in Normal Mode control register*/

#define UJA113X_NORMAL_MODE_ACTIVATION_TIME (320)	/*Delay before CAN and Battery monitoring are activated after the SBC switches to Normal mode*/


typedef enum

{
	uja113x_mode_off,								/*Initial State when power down*/
	uja113x_mode_reset,								/*Entered after Power On.*/
	uja113x_mode_overload,							/*Temperature or Overvoltage detected*/
	uja113x_mode_forced_normal,						/*Test mode for software evaluation. Factory default. Entered after Reset if FNMC bit was set*/
	uja113x_mode_fsp,								/*Forced Sleep Preparation Mode. Gets enabled after a serious System failure*/
	uja113x_mode_normal,							/*Normal operation mode. Watchdog is enabled in this mode*/
	uja113x_mode_standby,							/*entered if voltage too high or if RCC  3*/
	uja113x_mode_sleep,								/*Low power mode. Can be detected via SLPC */
	uja113x_mode_UNKNOWN							/* Unknown (by software)*/
} uja113x_mode;

typedef enum
{
	uja113x_modeCtrl_MC_NORMAL			= 0x7, /*111*/
	uja113x_modeCtrl_MC_STANDBY			= 0x4,
	uja113x_modeCtrl_MC_SLEEP			= 0x1
}
uja113x_modeCtrl_MC;


typedef enum
{
	uja113x_spi_access_READ					= 0x1,	/*Read Access Bit*/
	uja113x_spi_access_WRITE				= 0x0	/*No Access Bit*/
}uja113x_spi_access;

typedef enum
{
	uja113x_WD_PERIOD_8MS					= 0x8,	/*Watchdog period is 8 		milliseconds*/
	uja113x_WD_PERIOD_16MS					= 0x1,	/*Watchdog period is 16 	milliseconds*/
	uja113x_WD_PERIOD_32MS					= 0x2,	/*Watchdog period is 32 	milliseconds*/
	uja113x_WD_PERIOD_64MS					= 0xB,	/*Watchdog period is 64 	milliseconds*/
	uja113x_WD_PERIOD_128MS					= 0x4,	/*Watchdog period is 128 	milliseconds*/
	uja113x_WD_PERIOD_256MS					= 0xD,	/*Watchdog period is 256 	milliseconds*/
	uja113x_WD_PERIOD_1024MS				= 0xE,	/*Watchdog period is 1024 	milliseconds*/
	uja113x_WD_PERIOD_4096MS				= 0x7	/*Watchdog period is 4096 	milliseconds*/
}uja113x_WD_PERIOD;


typedef enum

{
	uja113x_register_WatchdogCtrl			= 0x00,	/*Watchdog Control Register*/
	uja113x_register_ModeCtrl				= 0x01, /*Mode Control Register*/
	uja113x_register_failsafeCtrl			= 0x02,
	uja113x_register_mainStatus				= 0x03,
	uja113x_register_SystemInterruptEnable	= 0x04,
	uja113x_register_WatchdogStatus			= 0x05,
	uja113x_register_Memory0				= 0x06,
	uja113x_register_Memory1				= 0x07,
	uja113x_register_Memory2				= 0x08,
	uja113x_register_Memory3				= 0x09,
	uja113x_register_LockCtrl				= 0x0A,
	/*0x0B to 0x0F are reserved.*/
	uja113x_register_RegulatorCtrl			= 0x10,
	uja113x_register_BatteryMon_IntCtrl		= 0x11,
	uja113x_register_BatteryMon_UVCtrl		= 0x12,
	uja113x_register_BatteryMon_OVCtrl		= 0x13,
	uja113x_register_BatteryMon_HysCtrl		= 0x14,
	uja113x_register_VBAT_ADC1Res			= 0x15,
	uja113x_register_VBAT_ADC2Res			= 0x16,
	uja113x_register_BATSENSE_ADC1Res		= 0x17,
	uja113x_register_BATSENSE_ADC2Res		= 0x18,
	uja113x_register_SMPS_Ctrl				= 0x19,
	uja113x_register_SMPS_VoltCtrl			= 0x1A,
	uja113x_register_SupplyVoltage_Status	= 0x1B,
	uja113x_register_SupplyIntEnable		= 0x1C,
	uja113x_register_CAN_Ctrl				= 0x20,	/*CAN Control Register*/
	/*0x1D to 0x1F are reserved*/
	uja113x_register_MTPNV_STATUS			= 0x70,	/*MTPNV Status Register*/
	uja113x_register_MTPNV_HVIO_HS_Ctrl		= 0x71,
	uja113x_register_MTPNV_HVIO_LS_Ctrl		= 0x72,
	uja113x_register_MTPNV_Startup_Ctrl		= 0x73,/*MTPNV Startup Register*/
	uja113x_register_MTPNV_SBCConfig_Ctrl	= 0x74,
	uja113x_register_MTPNV_CRC_Ctrl			= 0x75
	/*There are more Registers in UM. Feel free to add them if u need them. Please do not use address numbers in code.*/
}uja113x_register;

typedef enum
{
	uja113x_StartupControlData_RLC_20 		= 0x0,	/* Pulse width between 20ms and 25ms (factory defaults)*/
	uja113x_StartupControlData_RLC_10 		= 0x10,	/* Pulse width between 10ms and 12.5ms */
	uja113x_StartupControlData_RLC_3_6 		= 0x20,	/* Pulse width between 3.6ms and 5ms */
	uja113x_StartupControlData_RLC_1 		= 0x30,	/* Pulse width between 1ms and 1.5ms */
}uja113x_StartupControlData_RLC /*Determines Rest Pulse Width on cold start only.*/;

typedef enum
{
	uja113x_StartupControlData_V2SUC_Off  	= 0x0,	/* V2 is off after Reset (default)*/
	uja113x_StartupControlData_V2SUC_On  	= 0x08,	/* V2 is on */
}uja113x_StartupControlData_V2SUC /*Determines State of V2 regulator*/;

typedef enum
{
	uja113x_StartupControlData_IO4SFC_GPIO = 0x0,	/* Pin HVIO4 is standard IO Pins (default)*/
	uja113x_StartupControlData_IO4SFC_LIMP = 0x4,	/* Pin HVIO4 configured for LIMP Home*/
}uja113x_StartupControlData_IO4SFC					/*Determines usage of HVIO Pin 4*/;

typedef enum
{
	uja113x_StartupControlData_IO3SFC_GPIO = 0x0,	/* Pin HVIO3 is standard IO Pins (default)*/
	uja113x_StartupControlData_IO3SFC_LIMP = 0x2,	/* Pin HVIO3 configured for LIMP Home*/
}uja113x_StartupControlData_IO3SFC					/*Determines usage of HVIO Pin 3*/;

typedef enum
{
	uja113x_StartupControlData_IO2SFC_GPIO = 0x0,	/* Pin HVIO2 is standard IO Pins (default)*/
	uja113x_StartupControlData_IO2SFC_LIMP = 0x1,	/* Pin HVIO2 configured for LIMP Home*/
}uja113x_StartupControlData_IO2SFC					/*Determines usage of HVIO Pin 2s*/;



typedef enum
{
	SBC_ConfigurationControl_UV_detect_90 	= 0x00, /*!< Detect Undervoltage at 90% Factory Default Setting.>*/
	SBC_ConfigurationControl_UV_detect_80 	= 0x10, /*!< Detect Undervoltage at 80%>*/
	SBC_ConfigurationControl_UV_detect_70 	= 0x20, /*!< Detect Undervoltage at 70%>*/
	SBC_ConfigurationControl_UV_detect_60 	= 0x30, /*!< Detect Undervoltage at 60%>*/
}SBC_ConfigurationControl_UV_detect;

typedef enum
{
	SBC_ConfigurationControl_FNMC_OFF 		= 0x00,	/*!< Forced Normal Mode is off.>*/
	SBC_ConfigurationControl_FNMC_ON		= 0x08	/*!< Forced Normal mode is on (factory defaults)>*/
}SBC_ConfigurationControl_FNMC;

typedef enum
{
	SBC_ConfigurationControl_SDMC_OFF		= 0x00,	/*!< Software Development Mode off (factory default)>*/
	SBC_ConfigurationControl_SDMC_ON		= 0x04	/*!< Software Development Mode on. (Forces Watchdog to be initially disabled)>*/
}SBC_ConfigurationControl_SDMC;


typedef enum
{
	SBC_ConfigurationControl_VEXTAC_SensSupply= 0x00,/*!< V2 can be used as a sensor supply (factory default)>*/
	SBC_ConfigurationControl_VEXTAC_NoProtect = 0x02/*!< V2 not protected against shorts to HV. Must be shorted to VEXT then.>*/
}SBC_ConfigurationControl_VEXTAC;

typedef enum
{
	SBC_ConfigurationControl_SLPC_Support	 = 0x00,/*!< Enable Sleep Mode support (factory default)>*/
	SBC_ConfigurationControl_SLPC_NoSupport	 = 0x01	/*!< Do not support sleep mode.>*/
}SBC_ConfigurationControl_SLPC;

/*This should be the default setting in SBCConfig Control Register:*/
#define SBC_CONFIG_FACTORY_DEFAULT  					\
		(SBC_ConfigurationControl_UV_detect_90			\
			|SBC_ConfigurationControl_FNMC_ON 			\
			|SBC_ConfigurationControl_SDMC_OFF			\
			|SBC_ConfigurationControl_VEXTAC_SensSupply	\
			|SBC_ConfigurationControl_SLPC_Support)

typedef struct
{
	uja113x_mode			  mode;					/*(Last detected) mode of the SBC */
	//SpiIf_Ch		*spiChannel;			/*Pointer to SPI communication Channel*/
	UJA113X_transceive_device spiChannel;
}
uja113x_s;

typedef struct
{
	SBC_ConfigurationControl_UV_detect 	uv_detect;	/*UV Detect Register Value*/
	SBC_ConfigurationControl_FNMC 		fnmc;		/*FNMC Bit Register Value*/
	SBC_ConfigurationControl_SDMC 		sdmc;		/*SDMC Bit Register Value*/
	SBC_ConfigurationControl_VEXTAC 	vextac;		/*VEXTAC Bit Register Value*/
	SBC_ConfigurationControl_SLPC 		slpc;		/*SLPC Bit Register Value*/
} uja113x_SBCConfigData; /*Configuration data for SBC Config Register (MTPNV)*/

/*Not Used currently:*/
typedef struct
{
	uint8_t empty;
} uja113x_HVIO_HighSideControlData;

/*Not used currently:*/
typedef struct
{
	uint8_t empty;
} uja113x_HVIO_LowSideControlData;


typedef struct
{
	uja113x_StartupControlData_RLC    rlc;			/*RLC Bits*/
	uja113x_StartupControlData_V2SUC  v2suc;		/*V2SUC bit*/
	uja113x_StartupControlData_IO2SFC io2sfc;		/*IO2SFC*/
	uja113x_StartupControlData_IO3SFC io3sfc;		/*IO3SFC*/
	uja113x_StartupControlData_IO4SFC io4sfc;		/*IO4SFC*/
}uja113x_StartupControlData; /*Config Data for MTPNV Startup Control Reg*/

/*
 * Initiates MTPNV programming cycle if MTPNV programming is allowed.
 * Function takes desired configuration values and transmits them via SPI
 * After that CRC gets calculated and send aswell.
 *
 * @param 	uja_dev			Pointer to SBC device
 * @param	hs_control		Pointer to HS control settings (not used currently) , Specify 0 pointer for no changes.
 * @param   ls_control		Pointer to LS control settings (not used currently) , Specify 0 pointer for no changes.
 * @param	startup_control	Pointer to Statrup Control Register Configuration, Specify 0 pointer for no changes.
 * @param   config_data		Pointer to SBC Configuration Control Register, Specify 0 pointer for no changes (MTPNV wont work then...)
 * */
uint8_t uja113x_writeMTPNV
(
	const uja113x_s 							*uja_dev			/*SBC device*/
	,const uja113x_HVIO_HighSideControlData 	*hs_control
	,const uja113x_HVIO_LowSideControlData 		*ls_control
	,const uja113x_StartupControlData 			*startup_control
	,const uja113x_SBCConfigData				*config_data
);

/**
 *  Initiallizes uja_struct with specified SPI channel.
 *  Tries to communicate with SBC:
 *  An attempt is made to get the mode of the SBC device.
 *
 *  @param	uja_dev			Device to be initiallized
 *  @param	channelHandle	Pointer to Master channel
 *
 *  @returns				1 if mode is not off or unknown. Otherwise 0.
 */
uint8_t uja113x_init(uja113x_s *uja_dev, UJA113X_transceive_device channelHandle);

/*
 * tries to read register value at specified address.
 * Result value gets written in result
 *
 * @param	uja_dev			Pointer to initiallized SBC device
 * @param	address			Register Address
 * @param	result			Pointer to byte to write the result to.
 *
 * @returns					1 if read operation was succesful. 0 otherwise
 * */
uint8_t uja113x_readraw(const uja113x_s *uja_dev, uja113x_register address, uint8_t* result);

/*
 * Reads MTPNV SBC Configuration Register.
 *
 * @param	uja_device		Pointer to initialized SBC device
 * @param	config_data		Pointer to struct to write the read values to.
 *
 * @returns					1 if read operation succeeded. 0 otherwises
 * */
uint8_t uja113x_readSBCConfig
(
	const uja113x_s 							*uja_dev
	,uja113x_SBCConfigData*						config_data
);
uja113x_mode uja113x_getMode(const uja113x_s *uja_dev);



/*
 * Tries to satisfy the Watchdog via SPI
 * First of all an attempt is made to read the watchdog control register.
 * After that the Watchdog Control register gets fed with the desired period.
 *
 * @param	uja_dev		Pointer to SBC device
 * @param	period		Desired Watchdog Period
 * */
void uja113x_satisfyWatchdog(const uja113x_s *uja_dev,uja113x_WD_PERIOD period);


/*
 * Writes the desired 8-bit value to the specified address
 *
 * @param	uja_dev		Pointer to SBC Device
 * @param	address		Register Adress
 * @param	value		Desired Value
 *
 * returns 1 on success, 0 otherwise
 * */
uint8_t uja113x_writeAdress(const uja113x_s *uja_dev,uja113x_register address,uint8_t value);


/*
 *  Tries to read Voltage from SBC ADC (BAT)
 *  This operation fails if device is not in normal mode.
 *
 *  returns 1 on success, 0 otherwise
 *
 *  @param	device		Pointer to SBC device
 *  @param	spannung	Pointer to int16_t where voltage should be written to in case of success.
 *
 */
uint8_t uja113x_getBATVoltage(const uja113x_s *device, int16_t *spannung);

uint8_t uja113x_switchMode( uja113x_s *device, uja113x_mode mode);

#endif /* 0_SRC_2_CDRV_UJA11325_UJA11325_H_ */


