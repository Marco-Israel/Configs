
/*******************************************************************************
* @file             mi_ooc_elmos52042.h
* @author           Marco Israel
* @version          v. 1.o
* @date             2019-08
* @ingroup          mi_ooc
* @brief            elmos52042 SSP Sensor
* @copyright        Copyright (c) 2018 Marco Israel. All rights reserved.
*
*
*
*
*                      IMPORTANT NOTICE - COPYRIGHT INFORMATION
*
*
* English:
*
* THIS SOFTWARE AND ITS OBJECT ORIENTED ARCHITECTURE IN THE PROGRAMMING
* LANGUAGE C AS WELL AS THE NAMING CONVENTION IS PROVIDED "AS IS" by
* MARCO ISRAEL. ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO  EVENT SHALL MARCO ISRAEL
* BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY,
* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* The Lemfoerder Electronics GmbH, Bussche-Münch-Straße 12, 32339 Espelkamp,
* is allowed to use this object oriented software architecture as well
* as its naming conversation in and only in the their project
* 'ED0096_Swipetronic'. Marco Israel 2019 - 2020.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*     * Redistribution of source code must retain the this copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistribution in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in
*       the documentation and/or other materials provided with the
*       distribution.
*     * Neither the name of the <organization> nor the names of its
*       contributors may be used to endorse or promote products derived
*       from this software without specific prior written permission.
*
*
*
*
* German:
*
* Alle Inhalte in source und binaer Form, insbesondere die hier aufgezeigte
* object orientierte Softwarearchitektur- in der Programmiersprache C,
* seiner coding Conversation (Namensgebung etwa fuer Variablen, Funktionen,
* Parameter, Datentypen, usw.) sind urheberrechtlich geschuetzt.
* Alle Rechte, einschließlich der Verwendung, Veroeffentlichung, Bearbeitung,
* Uebersetzung oder Vervielfältigung, bleiben Marco Israel vorbehalten.
* Dieses gilt auch fuer alle Instanzen, Kopien oder sonstigen Verwendungen
* in source oder binearform. In jedem Fall sind diese Copyright und Urheber
* Informationen zu uebernehmen und duerfen nicht ohne Zustimmung vereandert
* oder entfernt werden. Marco Israel uebernimmt keine Haftung in irgendeiner
* Form und Art und Weise, die durch die Nutzung dieser Architektur oder seiner
* Kopien und Instancen in source oder binaerform direkt oder indirekt
* entstehen und kann nicht fuer Schaeden belangt werden.
*
* Die Lemfoerder Electronics GmbH, Bussche-Münch-Straße 12, 32339 Espelkamp,
* ist berechtigt dieses Template sowie seine object orientierte Software
* Architektur in C, als auch der die genutzte Namensgebungskonversation,
* innerhalb * und ausschliesslich fuer das * Project 'ED0096_Swipetronic'
* zu nutzen. Marco Israel 2019 - 2020.
*
*
*
*
********************************************************************************
* @detail
* ____TODO______
*
* The UML diagrams in this template folder provides you the context of template
* structure in a graphical view. Feel free to take a look at this diagrams.
* In case of questions you can contact me under Marco-Israel@online.de.
*
*
********************************************************************************
* @attention
* ____TODO______
*
* If you change something inside the template structure, do this in the
* template folder first and run 'make' inside the 'test' folder to see if
* the unittests still pass.
*
*
*******************************************************************************/



/*******************************************************************************
 **     INCLUDED GUARDS
 ******************************************************************************/

#ifndef ELMOS52042__H
#define ELMOS52042__H








/*******************************************************************************
 *******************************************************************************
 **                     DEFINITIONS
 *******************************************************************************
 ******************************************************************************/



/*******************************************************************************
 **     INCLUDED global defined information
 ******************************************************************************/
#include <mi_ooc.h>
#include <mi_ooc_sensor.h>




/*******************************************************************************
 **     Variables global EXTERN (public) definition
 ******************************************************************************/





/*******************************************************************************
 **     MACRO definition
 ******************************************************************************/


/**
 * You can define code her for handling constructor errors or exceptions.
 */
#ifndef ELMOS52042__ERROR_HANDLER__CTOR
#define ELMOS52042__ERROR_HANDLER__CTOR(ps__this)    \
    MI_OOC__ERROR_HANDLER__DEFAULT
#endif



/**
 * You can define code her for handling deconstructor errors or exceptions.
 */
#ifndef ELMOS52042__ERROR_HANDLER__DTOR
#define ELMOS52042__ERROR_HANDLER__DTOR(ps__this)    \
    MI_OOC__ERROR_HANDLER__DEFAULT
#endif


/**
 * You can define code her for handling cast from base to this.
 */
#ifndef ELMOS52042__ERROR_HANDLER__THIS_FROM_BASE
#define ELMOS52042__ERROR_HANDLER__THIS_FROM_BASE(ps__super, ps__vFTable)  \
    MI_OOC__ERROR_HANDLER__DEFAULT
#endif



/**
 * You can define code her for handling cast from base constructor parameters
 * to this constructor parameters.
 */
#ifndef ELMOS52042__ERROR_HANDLER__CTORPARAMLIST_FROM_BASE
#define ELMOS52042__ERROR_HANDLER__CTORPARAMLIST_FROM_BASE(ps__super)    \
    MI_OOC__ERROR_HANDER__DEFAULT
#endif




/*******************************************************************************
 **     Type GENERAL definition
 ******************************************************************************/



/**
 * The object itself
 */
typedef struct elmos52042__this__S    elmos52042__this__st;



/**
 * This attribuets (object variables and other data members)
 */
typedef struct elmos52042__thisAttribute__S elmos52042__thisAttribute__st;



/*
 * This virtual operations (virtual or abstract methods / functions)
 */
typedef struct elmos52042__thisVirtualOperation__S
            elmos52042__thisVirtualOperation__st;



/**
 * The constructor parameter list:  Variables parsed to the constructor
 * of 'this' object as function parameters.
 */
typedef struct elmos52042__ctorParamList__S  elmos52042__ctorParamList__st;



/**
 * The virtual Function Table (vFTable)
 */
typedef struct elmos52042__vFTable__S elmos52042__vFTable__st;


/**
 * The virtual Function Table (vFTable)
 */
typedef struct elmos52042__thisOwnVirtualOberation__S
            elmos52042__thisOwnVirtualOperation__st;


/*******************************************************************************
 **     Type FUNCTION POINTER definition
 ******************************************************************************/


/* ----- PART: VIRTUAL functions (methods) -----------------------------------*/



/* -------- END PART: VIRTUAL functions (methods) ----------------------------*/





/*******************************************************************************
 **     Type UNION definition
 ******************************************************************************/





/*******************************************************************************
 **     Type ENUM definition
 ******************************************************************************/





/*******************************************************************************
 **     Type STRUCTURE definition
 ******************************************************************************/






/**
 * Holding objects own virtual operations which still can be overwritten
 */
 struct elmos52042__thisOwnVirtualOberation__S {


    /** The error and exception handler */
    sensor__error__ft *         pf__errorHandler;



    /** A manchester decoding sending function */
    sensor__send__ft *          pf__manchesterSender;



    /**
     * A receive function like an analog, manchester decoding or SENT
     * protocol function.
     **/
    sensor__receive__ft *       pf__receiver;


};





/**
 * Attributes of this class and its instantiated objects
 */

 struct elmos52042__thisAttribute__S {


     /**
      * The ID or instance number of this object after it was allocated
      */

     uint8_t objectNr;

};





/**
 * Virtual Operations (virtual methods / functions) specific to this SUBclass
 */
struct  elmos52042__thisVirtualOperation__S {

};





/**
 * Object context, collects all public stuff of an instantiated class (object).
 */
struct elmos52042__this__S {


    /**
     * This SUBclass virtual functions, which can be replaced
     * during runtime individual for each object.
     */
    elmos52042__thisVirtualOperation__st* ps__virtualOperation;



    /**
     * Inherit (a copy of the) super (Base) object context.
     *
     *attention: NOTE: To prevent problems and to enable compatibility
     * it is recommended to make 'super' the first parameter.
     *
     *ATTention ATTENTION: This must be a COPY:
     * Otherwise it would not be possible to hold object independent values!
     */
    sensor__this__st base__S;



    /**
     * The collection ob object data member
     */
    elmos52042__thisAttribute__st attribute__S;



     /**
      * Own virtual operations of every single object. It can still be
      * overwritten but only for a single object each.
      */

    elmos52042__thisOwnVirtualOperation__st  ownVirtualOperation__S;








};





/**
 * The virtual functions table (vFTable) holds all virtual functions (methods)
 * which can be overwritten by the user during rue time.
 */
struct  elmos52042__vFTable__S {


    /**
     * Inherit (a copy of the) super (Base) object context.
     *
     *attention NOTE: To prevent problems and to enable compatibility
     * it is recommended to make 'super' the first parameter.
     *
     *attention ATTENTION: This must be a COPY: Otherwise it would not
     * not be possible to overwrite the base function pointers.
     */
    sensor__vFTable__st base__S;


    /*
     * Virtual operations (virtual methods or virtual functions)
     */
    elmos52042__thisVirtualOperation__st virtualOperation__S;


};





/**
 * Variables parsed to the constructor of 'this' object as function parameters.
 */
 struct elmos52042__ctorParamList__S {


    /**
    * Inherit (a copy of the) super (Base) object context.
    *
    *attention NOTE: To prevent problems and to enable compatibility
    * it is recommended to make 'super' the first parameter.
    *
    *attention ATTENTION: This must be a COPY:
    * Otherwise it would not be possible to hold object independent values!
    */
    sensor__ctorParamList__st base__S;


    /**
     * Parameters corresponding to this object data Members.
     */
    elmos52042__thisAttribute__st attribute__S;



     /**
      * Own virtual operations of every single object. It can still be
      * overwritten but only for a single object each.
      */

    elmos52042__thisOwnVirtualOperation__st  ownVirtualOperation__S;


};



/*******************************************************************************
 **     Function PUBLIC PROTOTYPE definition (extern)
 ******************************************************************************/



/* ----- PART: PUBLIC INLINE functions (methods) -----------------------------*/



/* -------- END PART: PUBLIC INLINE functions (methods) ----------------------*/





/* ----- PART: PUBLIC functions (methods) ------------------------------------*/


/**
 * Object allocator
 * Allocates memory if using the heap and initialize the objects members
 * (like the vFTable for instance).
 * @param ps__this This base object itself if it is already allocated in stack
 * or in the data memory segment. Otherwise parsing a NULL to this argument,
 * this function will try to allocate heap memory if __USING_HEAP__ is allowed.
 * @param ps__paramList List of function parameters.
 * @return Returns a pointer to this object. If the memory is allocated in heap
 * the function will return the pointer to the new heap data block after
 * it has allocated it. Otherwise it will return the pointer parsed given by
 * the parameter ps__this.
 *
 *attention: NOTE: There are different ways to allocate memory:
 * For instance, you can allocate memory in the stack, statically
 * in the data segment or manually from the heap. That is why you can
 * parse a pointer to 'this' to this function and get (maybe the same)
 * pointer returned.
 */
EXTERN elmos52042__this__st * elmos52042__new(
        elmos52042__this__st *const ps__this,
        elmos52042__ctorParamList__st *const ps__paramList);





/**
 * Object deallocator
 * Preform some cleanup stuff (like closing pipes) by calling
 * the deconstructor and free the memory if using the heap.
 * Last one is important when using the heap memory.
 * @param ps__this This derived object itself.
 */
EXTERN void elmos52042__deleate(elmos52042__this__st *const ps__this);





/**
 * Returns the class identifier
 * @param ps__this This base object itself
 * @return Returns the class identifier.
 */
EXTERN elmos52042__vFTable__st * elmos52042__get_classID(
        elmos52042__this__st *const ps__this);





/**
 * Returns the number of objects instantiated from this class.
 * @param ps_this This base object itsel.
 * @return Returns the number of currently active instances (objects)
 * allocated from this class.
 */
EXTERN uint8_t elmos52042__get_instanceCounter(
        elmos52042__this__st *const ps__this);





/**
 * Returns a pointer to the SUBclass by the pointer to the SUPERclass
 * @param ps_this This derived object itself.
 * @return Returns the pointer to this (its) base class object.
 */
EXTERN elmos52042__this__st * elmos52042__getPt_this__byPt_its_base(
        sensor__this__st *const ps__base);





/**
 * Returns a pointer to the SUBctorParamList by
 * the pointer to the SUPERctorParamList.
 * @param ps_baseCtorParamList The base _ctor paramList.
 * @return Returns a pointer to the base class _ctor paramList.
 */
EXTERN elmos52042__ctorParamList__st *
        elmos52042__getPt_ctorParamList__byPt_its_base(
               sensor__ctorParamList__st *const ps__baseCtorParamList);





/**
 * Returns if an object is an instance of  'this'  base class.
 * @param ps_this This derived object itself,
 * @returns Returns TRUE if the given object is an instance of this base class.
 */
EXTERN bool_t elmos52042___is_this__instance_of_base(
        sensor__this__st *const ps__base);



/* -------- END PART: PUBLIC functions (methods) -----------------------------*/





/* ----- PART: PROTECTED functions (methods) ---------------------------------*/


/**
 * Returns a pointer to the objects private virtual Function Table (vFTable),
 * @return Returns a const pointer to a const vFTable which can not be modified.
 *
 * NOTE: This function should be 'protected' or 'restricted. That is why
 * this function is prefixed by an '_' (underscore)
 *
 *attention: ATTENTION; The function does care about if the vFTable is
 * already initialized or not.
 */
EXTERN elmos52042__vFTable__st * _elmos52042__getPt_vFTable(void);



/* -------- END PART: PROTECTED functions (methods) --------------------------*/








/*******************************************************************************
 *******************************************************************************
 **                     IMPLEMENTATIONS
 *******************************************************************************
 ******************************************************************************/



/*******************************************************************************
 **     Function INLINE implementation
*******************************************************************************/



/* ----- PART: NORMAL object functions (methods) -----------------------------*/


/**
 * @brief Returns the number of this object which was assigend after new().
 * @Param ps__this Pointer to object
 *
 * @Returns Returns the number of this object which was assigend after new().
 */
STATIC INLINE uint8_t elmos52042__get_ObjectNr(
        elmos52042__this__st *const ps__this
        )
{

    return ps__this->attribute__S.objectNr;


}



/* -------- END PART: Normal object functions (methods) ----------------------*/





/* ----- PART: SET and GET (setter and getter) functions ---------------------*/


STATIC INLINE void elmos52042__setPt_ownVirtualOperation(
        elmos52042__this__st *const ps__this,
        elmos52042__thisOwnVirtualOperation__st *const ps__ownVirtualOperation)
{


    if(NULLp != ps__ownVirtualOperation->pf__errorHandler) {
            ps__this->ownVirtualOperation__S.pf__errorHandler =
            ps__ownVirtualOperation->pf__errorHandler;
    }



    if(NULLp != ps__ownVirtualOperation->pf__manchesterSender) {

            ps__this->ownVirtualOperation__S.pf__manchesterSender =
            ps__ownVirtualOperation->pf__manchesterSender;
    }



    if(NULLp != ps__ownVirtualOperation->pf__receiver) {
            ps__this->ownVirtualOperation__S.pf__receiver =
            ps__ownVirtualOperation->pf__receiver;
    }


}





/* -------- END PART: SET and GET (setter and getter) functions --------------*/





/* ----- PART: VIRTUAL object functions (methods) ----------------------------*/


/**
 * Direct call to virtual the base errorHandler.
 * @param ps__this This base object itself.
 * @param ps__paramList List of function parameters.
 */
STATIC INLINE void elmos52042__erroHandler(
        elmos52042__this__st *const ps__this,
        sensor__errorHandlerParamList__st *const ps__paramList)
{

    if(NULLp != ps__this->ownVirtualOperation__S.pf__errorHandler)
    {
        ps__this->ownVirtualOperation__S.pf__errorHandler(
                &ps__this->base__S,ps__paramList);

    }
    else{

        ps__this->base__S.ps__virtualOperation->pf__errorHandler(
                &ps__this->base__S,ps__paramList);
    }

}




/**
 * @brief  Recive data from the Sensor
 *
 * @Param ps__this This Sensor object
 * @Param pa__dataSrc The destination buffer where to store the received data
 * @Param lengthOfSrc The size of the destination buffer in bytes
 *
 * @Returns Returns the number of bytes sanded
 */
STATIC INLINE uint8_t  elmos52042__send(
        elmos52042__this__st *const ps__this, uint8_t *const pa__dataSrc,
        uint8_t lengthOfSrc )
{

    if(NULLp !=
            ps__this->ownVirtualOperation__S.pf__manchesterSender)
    {

       return  ps__this->ownVirtualOperation__S.
           pf__manchesterSender(&ps__this->base__S, pa__dataSrc,lengthOfSrc );

    }
    else
    {

       return  ps__this->base__S.ps__virtualOperation->pf__send(
                &ps__this->base__S, pa__dataSrc, lengthOfSrc);

    }
}





/**
 * @brief  Receive data from the Sensor
 *
 * @Param ps__this This base Sensor object
 * @Param pad__dataDest A pointer to the Destination Buffer.
 * @Param sizeOfDstination The size of the destination buffer in bytes
 * @attation NOTE: The data in the buffer will be overwirtten.
 *
 * @Returns The number of bytes received and written to the pad__dataDest .
 */
STATIC INLINE uint8_t elmos52042__receive(
        elmos52042__this__st *const ps__this, uint8_t *const pad__dataDest,
        uint8_t sizeOfDstination)
{

    if(NULLp != ps__this->ownVirtualOperation__S.pf__receiver)
    {

       return  ps__this->ownVirtualOperation__S.
           pf__receiver(&ps__this->base__S, pad__dataDest,sizeOfDstination);

    }
    else
    {
       return  ps__this->base__S.ps__virtualOperation->pf__receive(
                &ps__this->base__S, pad__dataDest, sizeOfDstination);

    }


}


/* ---------- END PART: Virtual object functions (methods) -------------------*/






/* ----- PART: CLEAN CODE (Local helper) Functions ---------------------------*/

/*--------------------- END PART: CLEAN CODE (Local helper) Functions --------*/


/* ----- PART: STATIC (Local) Functions --------------------------------------*/

/*--------------------- END PART: STATIC (Local) Functions -------------------*/


/* ----- PART: EXTERN (Global) Functions -------------------------------------*/

/*--------------------- END PART: EXTERN (Global) Functions ------------------*/



/**************** (C) COPYRIGHT Marco Israel ****** END OF FILE ***************/

#endif /*ELMOS52042__H*/
