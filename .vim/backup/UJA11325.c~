/*
 * UJA11325.c
 *
 *  Created on: 28.05.2019
 *      Author: Z602900
 */


#include "UJA11325.h"
#include "aurix_activeWait.h"

/*
 * Non public Helper Function for Data exchange
 *
 * @param		uja_dev			Pointer to valid SBC device
 *
 * @param		tx_data			Pointer to 1-dimensional byte array with length of two
 * 								Contains data to be transmitted
 *
 * @param		rx_data			Pointer to 1-dimensional byte array with length of two
 * 								Should contain received datas
 *
 * @returns						one if first byte of rxdata matches first byte of rxdata after read operation.
 * 								zero otherwise.
 *
 * */
uint8_t uja113x_dataExchange16(uja113x_s *uja_dev,uint8_t *txdata,uint8_t *rxdata)
{
	uint8_t success = 0;
	uja113x_block_spi_busy(uja_dev->spiChannel);
	uja113x_dataInterchange(uja_dev->spiChannel,txdata,rxdata);
	uja113x_block_spi_busy(uja_dev->spiChannel);
	if (txdata[0] == rxdata[0])
	{//See Datasheet. SBC always repeats the transmitted address.
		success 						= 1;
	}
	return success;
}
/*
 * Helper function returning 1 iff MTPNV programming is allowed
 *
 *	@param 		uja_dev			Pointer to valid SBC device
 * */

uint8_t uja113x_is_mtpnv_programming_allowed(const uja113x_s *uja_dev)
{
	uint8_t success 					= 0; /*Return value*/
	uint8_t mtpnvStatusReg 				= 0;
	if (uja113x_mode_forced_normal == uja113x_getMode(uja_dev))						/*Mode retrieved and forced normal*/
	{
		if (uja113x_readraw(uja_dev,uja113x_register_MTPNV_STATUS,&mtpnvStatusReg))	/*Read MTPNV Status Register*/
		{//Successfull read of MTPNV Programming Status Register
			if (mtpnvStatusReg & 0x1) //TODO: DEFINE IT OR STH						/*MTPNV Programming allowed indcated by MTPNV Status reg*/
			{//Programming is allowed !
				success 				= 1;
			}
		}
	}
	return success ;
}

/*
 * Helper function, calculating CRC for MTPNV Programming
 *
 * @param			mtpnvdata			Bytes to be written to MTPNV register
 * 										IN ASCENDING ORDER !!!!!!!!!!!
 * 										LENGTH OF 4
 *
 * returns								calculated CRC
 * */
uint8_t uja113x_calculate_MTPNV_CRC(uint8_t *mtpnvdata)
{
	/*Copy and pasted from User manual*/
	uint8_t crc 						= 0xFF;
	uint8_t data 						= 0;
	uint8_t data_index 					= 0;
	uint8_t j 							= 0;
	for (data_index = 0;data_index < 4;data_index++)
	{
		data = mtpnvdata[data_index] ^ crc;
		for (j= 0; j < 8;j++)
		{

			if (data >= 128)
			{
				data 					*=2;
				data 					^= 0x2F;
			}
			else
			{
				data 					*=2;
			}
		}
		crc 							= data;
	}
	crc 								^= 0xFF;
	return crc;
}


void uja113x_satisfyWatchdog(const uja113x_s *uja_dev,uja113x_WD_PERIOD period)
{
																					//Read Watchdog Bits of register field WMC
	uint8_t wmc_bits;
	uint8_t reachable 					=  uja113x_readraw(uja_dev,uja113x_register_WatchdogCtrl,&wmc_bits);
	wmc_bits 							&= UJA113X_WD_CTRL_WMC_MSK;					/*Mask out other bits*/
	if ( reachable)
	{//Device unreachable
		wmc_bits 						= 0x40;
	}
	uint8_t value 						= (wmc_bits) | (period & UJA113X_WD_CTRL_NWP_MSK);
	uja113x_writeAdress(uja_dev,uja113x_register_WatchdogCtrl,value); 				/*Write operation to WD CTRL to satisfy the dog. WOW !*/
}

uint8_t uja113x_init(uja113x_s *uja_dev, UJA113X_transceive_device channelHandle)
{
	uja_dev->spiChannel 				= channelHandle;							/*Init SPI Channel Pointer*/
	uja113x_mode mode 					= uja113x_mode_UNKNOWN;						/* Initialize mode to unknown*/
	mode 								= uja113x_getMode(uja_dev);					/*Get Mode*/
	uja_dev->mode 						= mode;
	return !((mode == uja113x_mode_UNKNOWN) || (mode == uja113x_mode_off));			/*Only return 1 if Mode is known and not off.s*/
}



uint8_t uja113x_writeAdress(const uja113x_s *uja_dev,uja113x_register address,uint8_t value)
{
	uint8_t success 				= 0;	//Return values
	uint8_t command[2] 				= {0};	//Command to be transmitted
	volatile uint8_t response[2] 	= {0};	// The response
	command[0]						= (address << 1) | uja113x_spi_access_WRITE;		/*Write Access Flag*/
	command[1]						= value;
	success 						= uja113x_dataExchange16(uja_dev,command,response);	/*Call helper function*/
	return success;
}

uint8_t uja113x_writeMTPNV
(
	const uja113x_s *uja_dev
	,const uja113x_HVIO_HighSideControlData 	*hs_control
	,const uja113x_HVIO_LowSideControlData 	*ls_control
	,const uja113x_StartupControlData 			*startup_control
	,const uja113x_SBCConfigData				*config_data
)
{
	uint8_t success 				= 0;											/*Return values*/
	uint8_t programdata[4] 			= {0};											/*Data to be programmed*/
	uint8_t abort 					= 0;											/*Abort flag.*/
	uint8_t wrtHsControl 			= (hs_control != 0);							/*Determine if HVIO High side shall be configured*/
	uint8_t wrtLsControl 			= (ls_control != 0);							/*Determine if HVIO Low side shall be configured*/
	uint8_t wrtStartUpControl 		= (startup_control != 0);						/*Determine if Startup Control shall be configured*/
	uint8_t wrtSBCConfig    		= (config_data != 0);							/*Determine if SBC shall be configured*/


	if ( uja113x_is_mtpnv_programming_allowed(uja_dev))
	{
		if(wrtHsControl && !abort)
		{
			programdata[0]			= hs_control->empty;
			abort = !uja113x_writeAdress(uja_dev,uja113x_register_MTPNV_HVIO_HS_Ctrl,programdata[0]);
		}
		if(wrtLsControl		&& !abort)
		{
			programdata[1]			= ls_control->empty;
			abort = !uja113x_writeAdress(uja_dev,uja113x_register_MTPNV_HVIO_LS_Ctrl,programdata[1]);
		}
		if(wrtStartUpControl	&& !abort)
		{
			programdata[2]			= startup_control->rlc
					|startup_control->v2suc
					|startup_control->io2sfc
					|startup_control->io3sfc
					|startup_control->io4sfc;
			abort = !uja113x_writeAdress(uja_dev,uja113x_register_MTPNV_Startup_Ctrl,programdata[2]);
		}
		if(wrtSBCConfig		&& !abort)
		{
			programdata[3]			=
					config_data->fnmc
					|config_data->sdmc
					|config_data->slpc
					|config_data->uv_detect
					|config_data->vextac;
			abort = !uja113x_writeAdress(uja_dev,uja113x_register_MTPNV_SBCConfig_Ctrl,programdata[3]);
		}
		if (!abort)
		{
			volatile uint8_t crc = uja113x_calculate_MTPNV_CRC(programdata);
			uja113x_writeAdress(uja_dev,uja113x_register_MTPNV_CRC_Ctrl,crc); //AND THE WORLD ENDS !
		}
		success = !abort;
	}

	return success;
}

uja113x_mode uja113x_getMode(const uja113x_s *uja_dev)
{
	uja113x_mode mode 					= uja113x_mode_UNKNOWN; 					/* Return value. current Mode of SBC*/
	uint8_t mainStatusValue				= 0;										/* Read value from main status register*/
	uint8_t forcedNormal 				= 0;										/* Determines if SBC is in forced normal mode*/
	uint8_t normalMode 					= 0;										/* Determines if SBC is in normal mode*/
	uint8_t modeControlRegVal 			= 0;										/* Value from Mode Control Register, invalid in fcm.*/
	uint8_t sleepMode 					= 0;										/* Determines if SBC is in sleep mode*/
	uint8_t standbyMode 				= 0;										/* Determines if SBC is in standby mode*/
	uint8_t deviceReachable 			= uja113x_readraw(uja_dev,uja113x_register_mainStatus,&mainStatusValue);
	uja113x_SBCConfigData config_data 	= {0};

	if (deviceReachable)
	{
		deviceReachable 				= uja113x_readSBCConfig(uja_dev,&config_data);
		forcedNormal					= deviceReachable ? config_data.fnmc : 0;
		normalMode 						= (0 == mainStatusValue & 0x20 >> 5);
		if ( !forcedNormal && !normalMode)
		{//Only then following commands are allowed.
			if (uja113x_readraw(uja_dev,uja113x_register_ModeCtrl,&modeControlRegVal))
			{
				normalMode 				= (modeControlRegVal & UHA113x_MODE_CTRL_MC_MSK) == uja113x_modeCtrl_MC_NORMAL;
				standbyMode 			= (modeControlRegVal & UHA113x_MODE_CTRL_MC_MSK) ==  uja113x_modeCtrl_MC_STANDBY;
				sleepMode   			= (modeControlRegVal & UHA113x_MODE_CTRL_MC_MSK) == uja113x_modeCtrl_MC_SLEEP;
				uint8_t wdt_ctrl, wdt_state;
				uja113x_readraw(uja_dev,uja113x_register_WatchdogCtrl, &wdt_ctrl);
				uja113x_readraw(uja_dev,uja113x_register_WatchdogStatus,&wdt_state);
			}
		}
	}
	mode = deviceReachable ?														/*If device unreachable mode is not know, but most likely its Reset.s*/
				forcedNormal ?														/*If forced normal bit detected device is in forced normal mode*/
						uja113x_mode_forced_normal
						: normalMode ?												/*If Normal Mode bit detected device is in normal mode*/
								uja113x_mode_normal
								: sleepMode ?										/*If sleep mode bit detected device is in sleep mode*/
										uja113x_mode_sleep
										: standbyMode ?								/*If standbys mode bit detected device is in standby mode*/
												uja113x_mode_standby
												: uja113x_mode_UNKNOWN
		  :uja113x_mode_UNKNOWN;
	return mode;
}

uint8_t uja113x_readraw(const uja113x_s *uja_dev, uja113x_register address, uint8_t* result)
{
	uint8_t 			command[2] 		= {0};
	volatile uint8_t 	response[2] 	= {0};
	uint8_t success 		= 0;
	command[0] = address << 1 | uja113x_spi_access_READ;
	command[1] = 0x00;

	success = uja113x_dataExchange16(uja_dev,command,response);
	*result = response[1];
	return success;
}

uint8_t uja113x_readSBCConfig
(
	const uja113x_s 					*uja_dev
	,uja113x_SBCConfigData				*config_data
)
{
	//TODO
	volatile uint8_t rawVal = 0;
	uint8_t success = uja113x_readraw(uja_dev,uja113x_register_MTPNV_SBCConfig_Ctrl,&rawVal);
	if (success)
	{
		config_data->fnmc 				= rawVal & SBC_ConfigurationControl_FNMC_ON;
		config_data->sdmc 				= rawVal & SBC_ConfigurationControl_SDMC_ON;
		config_data->slpc 				= rawVal & SBC_ConfigurationControl_SLPC_NoSupport;
		config_data->uv_detect 			= rawVal & SBC_ConfigurationControl_UV_detect_60;
		config_data->vextac 			= rawVal & SBC_ConfigurationControl_VEXTAC_NoProtect;
	}
	return success;
}

uint8_t uja113x_getBATVoltage(const uja113x_s *device, int16_t *spannung)
{
	uint8_t success = 0;
	uja113x_mode mode = uja113x_getMode(device);
	uint8_t spannung1,spannung2;
	if (uja113x_mode_normal == mode)
	{
		success 						= uja113x_readraw(device,uja113x_register_VBAT_ADC1Res,&spannung1);
		success 						= success ? uja113x_readraw(device,uja113x_register_VBAT_ADC2Res,&spannung2)
											: 0;
		*spannung 						= success ? (spannung1<<2|(spannung2 & 0x3))*20/1024
											: *spannung;
	}
	return success;
}


uint8_t uja113x_switchMode( uja113x_s *device, uja113x_mode mode)
{
	uint8_t success = 0;
	device->mode = uja113x_getMode(device);											/*First of all: Get the current mode.*/
	if(uja113x_mode_standby == device->mode || uja113x_mode_normal == device->mode)
	{/*Switching modes is allowed in standby mode or normal mode only*/
		uint8_t mc_value = 0;
		switch(mode)
		{
			case(uja113x_mode_normal):
			{
				mc_value = uja113x_modeCtrl_MC_NORMAL;
				break;
			}
			case(uja113x_mode_sleep):
			{
				mc_value = uja113x_modeCtrl_MC_SLEEP;
				break;
			}
			case(uja113x_mode_standby):
			{
				mc_value = uja113x_modeCtrl_MC_STANDBY;
				break;
			}
			default:
			{
				mc_value = 0;
			}
		}
		if (0 < mc_value)
		{
			uja113x_writeAdress(device,uja113x_register_ModeCtrl,mc_value);			/*Switch to normal mode*/
			device->mode = uja113x_getMode(device);
			success = (device->mode == mode);
		}
	}
	return success;

}
