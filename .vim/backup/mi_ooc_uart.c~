
/*******************************************************************************
* @file             mi_ooc_uart.c
* @author           Marco Israel
* @version          v. 6.0
* @date             2019-06
* @ingroup          mi_ooc
* @copydoc          mi_ooc_mi_ooc_b1.h
* @brief            Abstract UART base object
* @copyright        Copyright (c) 2018 Marco Israel. All rights reserved.
*
*
*
*
*                      IMPORTANT NOTICE - COPYRIGHT INFORMATION
*
*
* English:
*
* THIS SOFTWARE AND ITS OBJECT ORIENTED ARCHITECTURE IN THE PROGRAMMING
* LANGUAGE C AS WELL AS THE NAMING CONVENTION IS PROVIDED "AS IS" by
* MARCO ISRAEL. ANY EXPRESS OR IMPLIED  WARRANTIES, INCLUDING, BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO  EVENT SHALL MARCO ISRAEL
* BE LIABLE FOR ANY DIRECT, INDIRECT, * INCIDENTAL, SPECIAL, EXEMPLARY,
* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* The Lemfoerder Electronics GmbH, Bussche-Münch-Straße 12, 32339 Espelkamp,
* is allowed to use this object oriented software architecture as well
* as its naming conversation in and only in the their project
* 'ED0096_Swipetronic'. Marco Israel 2019 - 2020.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
*     * Redistribution of source code must retain the this copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistribution in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in
*       the documentation and/or other materials provided with the
*       distribution.
*     * Neither the name of the <organization> nor the names of its
*       contributors may be used to endorse or promote products derived
*       from this software without specific prior written permission.
*
*
*
* German:
*
* Alle Inhalte in source und binaer Form, insbesondere die hier aufgezeigte
* object orientierte Softwarearchitektur- in der Programmiersprache C,
* seiner coding Conversation (Namensgebung etwa fuer Variablen, Funktionen,
* Parameter, Datentypen, usw.) sind urheberrechtlich geschuetzt.
* Alle Rechte, einschließlich der Verwendung, Veroeffentlichung, Bearbeitung,
* Uebersetzung oder Vervielfältigung, bleiben Marco Israel vorbehalten.
* Dieses gilt auch fuer alle Instanzen, Kopien oder sonstigen Verwendungen
* in source oder binearform. In jedem Fall sind diese Copyright und Urheber
* Informationen zu uebernehmen und duerfen nicht ohne Zustimmung vereandert
* oder entfernt werden. Marco Israel uebernimmt keine Haftung in irgendeiner
* Form und Art und Weise, die durch die Nutzung dieser Architektur oder seiner
* Kopien und Instancen in source oder binaerform direkt oder indirekt
* entstehen und kann nicht fuer Schaeden belangt werden.
*
* Die Lemfoerder Electronics GmbH, Bussche-Münch-Straße 12, 32339 Espelkamp,
* ist berechtigt dieses Template sowie seine object orientierte Software
* Architektur in C, als auch der die genutzte Namensgebungskonversation,
* innerhalb * und ausschliesslich fuer das * Project 'ED0096_Swipetronic'
* zu nutzen. Marco Israel 2019 - 2020.
*
*
*
*
********************************************************************************
* @detail
* Abstract UART base object
*
* In case of questions you can contact me under Marco-Israel@online.de.
*
*
********************************************************************************
* @attention
*
* If you change something inside the template structure, do this in the
* template folder first and run 'make' inside the 'test' folder to see if
* the unittests still pass.
*
*
********************************************************************************
* @todo
*
* - Initialize UART HW in the CTor
* - Add switch/case to ctor to assigne UART1_<function>, UART2_<function>, ...
*   to the function pointer according to the hwNr.
* - Ask the PORT_PIN Object to set the alternate Function and other pin/port
*   settings to UARTA1. A PORT_PIN object is needed before.
*
*
*******************************************************************************/








/*******************************************************************************
 *******************************************************************************
 **                     DEFINITIONS
 *******************************************************************************
 ******************************************************************************/



/*******************************************************************************
 **     INCLUDED global defined information
 ******************************************************************************/

#include <mi_ooc_uart.h>
#include <mi_ooc_uartWrapper.h>


/*******************************************************************************
 **     MACRO definition
 ******************************************************************************/




/*******************************************************************************
 **     Type GENERAL definition
 ******************************************************************************/




/*******************************************************************************
 **     Type FUNCTION POINTER definition
 ******************************************************************************/




/*******************************************************************************
 **     Type UNION definition
 ******************************************************************************/




/*******************************************************************************
 **     Type ENUM definition
 ******************************************************************************/




/*******************************************************************************
 **     Type STRUCTURE definition
 ******************************************************************************/






/*******************************************************************************
 **     Function PRIVATE PROTOTYPE definition (static)
 ******************************************************************************/



/* ----- PART: INLINE prototypes ---------------------------------------------*/


/**
 * Returns a pointer to the objects private virtual Function Table (vFTable)
 * If not the table will be initialized first.
 *
 * @return Returns a pointer to the objects private virtual Function Table
 * (vFTable). If not the table will be initialized first.
 */
STATIC INLINE uart__vFTable__st *
                  _uart__getPt_initialized_vFTable(void);


/* -------- END PART: INLINE prototypes --------------------------------------*/





/* ----- PART: Virtual prototypes --------------------------------------------*/


 /**
  * Default constructor.
  * @param ps__this This base object itself.
  * @param ps__paramList List of function parameters.
  */
STATIC void _ctor(uart__this__st* const ps__this,
    uart__ctorParamList__st *const  ps__paramList);





/**
 * Default destructor.
 * @param ps__this This base object itself.
 */

STATIC void _dtor(uart__this__st *const ps__this);





/**
* Default error handler,
 * @param ps__this This base object itself.
 * @param ps__paramList List of function parameters.
*/
STATIC void _errorHandler(uart__this__st *const ps__this,
        uart__errorHandlerParamList__st *const ps__paramList);





/**
 * Write a softwarebuffer out via uart
 * @param ps__this This base object itselfe.
 * @param pa__source source buffer
 * @param numberOfBytes The number of bytes to transmit
 * @param Returns the number of sendet bytes.
 */

STATIC uint8_t _send_uart1(uart__this__st *const ps__this,
        uint8_t *const pa__source, uint8_t bytesToSend);





/**
 * Receive data via UART
 * @param ps_this This base object itself,
 * @param opa__destination The destination buffer to overwrite with the new data
 * @param destinationBufferSize the maximum size of the buffer to write new data
 * @return Returns the number of Bytes received and written to the buffer
 */

STATIC uint8_t _receive_uart1( uart__this__st *const ps__this,
        uint8_t *const opa__destination, uint8_t destinationBufferSize);



    //BEGIN*****TODO***************TODO***************TODO*****BEGIN


    //END*******TODO***************TODO***************TODO*******END



/* -------- END PART: Virtual prototypes -------------------------------------*/





/* ----- PART: APPLICATION prototypes ----------------------------------------*/


/**
 * Initialized the virtual Function Table (vFTable) if its not.
 */
STATIC void _vFTable__init_if_uninitialized(void);


/* -------- END PART: APPLICATION prototypes ---------------------------------*/








/*******************************************************************************
 *******************************************************************************
 **                     IMPLEMENTATIONS
 *******************************************************************************
 ******************************************************************************/



/*******************************************************************************
 **     Variables global EXTERN (Public) implementation
 ******************************************************************************/





/*******************************************************************************
 **     Variables global STATIC (Private) implementation
 ******************************************************************************/

/**
 * A table holding virtual function which can be replaced during run-time.
 * Such functions are called 'virtual' in OOC context.
 *
 * NOTE 1: Because we want only one virtual function table (vFTable) for each
 * 'Class', not for each instance of a 'Class' (called 'object'), the virtual
 * function table is allocated in the data segment. So the vFTable must be
 * initialized only once. Each instance have afterwards the same (overwritten)
 * functions (methods) (also if the first instance gets deleted).
 *
 * NOTE 2: This makes it also easy to use its address as an object identifier.
 */
static uart__vFTable__st   _vFTable_S = {
    .virtualOperation__S.pf__ctor=&_ctor,
    .virtualOperation__S.pf__dtor =  &_dtor,
    .virtualOperation__S.pf__errorHandler = &_errorHandler,
    .virtualOperation__S.pf__uartSend = &_send_uart1,
    .virtualOperation__S.pf__uartReceive = &_receive_uart1
};




/**
 * Flag to indicate if the vFTable is (already) initialized or not.
 * This should normally be done by the constructor during the first
 * instantiating of this object.
 */
static uint8_t  _activeInstanceCounter = __MI_OOC__NOT_INITIALIZED__;






/*******************************************************************************
 **     Function PRIVATE INLINE implementation (STATIC inline)
 ******************************************************************************/



STATIC INLINE uart__vFTable__st *
           _uart__getPt_initialized_vFTable(void)
{
    _vFTable__init_if_uninitialized();

    return &_vFTable_S;

}





/*******************************************************************************
 **     Function PRIVATE implementation (static)
 ******************************************************************************/


STATIC void _ctor(uart__this__st* const ps__this,
        uart__ctorParamList__st *const  ps__paramList)
{

    if (NULLp != ps__this) {

        /** Initialize this vFTable and link it to this object. */
        _vFTable__init_if_uninitialized();

        ps__this->ps__virtualOperation = &_vFTable_S.virtualOperation__S;


         //BEGIN*****TODO******************TODO******************TODO

        if (NULLp != ps__paramList) {
            /*
             * @todo: TODO construct the object with the
             * paramList values.
             */
            ps__this->attribute__S.hwNr=
                ps__paramList->attribute__S.hwNr;

        }
        else {
             /*
              * @todo: TODO set default values if no parameter are
              * parsed to this constructor.
              */
            ps__this->attribute__S.hwNr = 0x01;
        }


        _uart1__initialize_the_hw();


        //END*******TODO******************TODO******************TODO

    }
    else
    {
        __UART__ERROR_HANDLER__CTOR__(ps__this)
    }

}





STATIC void _dtor(uart__this__st *const ps__this)
{


    if (NULLp != ps__this) {


        //BEGIN*****TODO******************TODO******************TODO
        /*
         * Base object deconstruction code.
         * The base dtor shall deconstruct the base struct (object)
         * members and preform cleanup like closing pipes.
         * @todo TODO: Implement  'this'  destructor code TODO.
         */
        ps__this->attribute__S.hwNr = 0u;
         int ___TODO___;
         (void)___TODO___;
       //END*******TODO******************TODO******************TODO

    }
    else {
            __UART__ERROR_HANDLER__DTOR__(ps__this)
    }

}





STATIC void _errorHandler(uart__this__st *const ps__this,
        uart__errorHandlerParamList__st *const ps__paramList)
{

    if(NULLp != ps__this){

        if(NULLp != ps__paramList){


        }
        else{

        }
    }

    (void)ps__this;
    (void)ps__paramList;
    __MI_OOC__ERROR_HANDLER__DEFAULT__

}






STATIC uint8_t _receive_uart1(uart__this__st * ps__this,
        uint8_t* opa__destination, uint8_t destinationBufferSize)
{

    (void)opa__destination;
    (void)destinationBufferSize;
    (void)ps__this;

    uint8_t bytesReceived=0u;


    if( (NULLp != ps__this) && (NULLp != opa__destination) )
    {

        if(__MI_OOC_UARAT1_HWNR__ == ps__this->attribute__S.hwNr)
        {


            _uart1__enable_rx_if_not();


            if( (TRUE == _uart1__is_rx_ready()) && (
                        TRUE == _uart1__rx_has_data()) ){

                _uart1__receive();
            }

            else{

                __UART__ERROR_HANDLER__RECEIVE__(ps__this, opa__destination,
                        bytesReceived);

            }/*(__MI_OOC_UARAT1_HWNR__ == ps__this->attribute__S.hwNr) */
        }

    }
    else{

        __MI_OOC__ERROR_HANDLER__NULL_POINTER__

    }


    return bytesReceived;

}





STATIC uint8_t _send_uart1(uart__this__st * ps__this, uint8_t* pa__source,
        uint8_t bytesToSend)
{

    uint8_t bytesSended = 0;

    if( (NULLp != ps__this) && (NULLp != pa__source) )
    {


        if(__MI_OOC_UARAT1_HWNR__ == ps__this->attribute__S.hwNr) {


            _uart1__enable_tx_if_not();


            if(TRUE == _uart1__is_tx_ready() ){

                for(; bytesSended <  bytesToSend; bytesSended++)
                {
                    _uart1__send(pa__source[bytesSended]);
                }

            }
            else{

         __UART__ERROR_HANDLER__SEND__(ps__this, pa__source,bytesSended)

            }

        } /*(__MI_OOC_UARAT1_HWNR__ == ps__this->attribute__S.hwNr) */

    } /*( (NULLp != ps__this) && (NULLp != pa__source) ) */
    else{
        __MI_OOC__ERROR_HANDLER__NULL_POINTER__

    }

    return bytesSended;

}

//BEGIN*****TODO******************TODO******************TODO




//END*******TODO******************TODO******************TODO



/* -------- END PART: Virtual functions --------------------------------------*/





/* ----- PART: APPLICATION functions -----------------------------------------*/



STATIC void _vFTable__init_if_uninitialized(void)
{

    /*
     * Prevent a reinitialization after the class was instantiated
     * at least one time or more. This would reset the vFTable.
     */

    if (__MI_OOC__NO_INSTANCE__ == _activeInstanceCounter) {

        //BEGIN*****TODO******************TODO******************TODO


        /*First set default virtual function. There are at least
         * the default constructor and deconstructor to set as well
         * as a default error handling function.
         */
        //_vFTable_S.virtualOperation__S.pf__ctor = &_ctor;
        //_vFTable_S.virtualOperation__S.pf__dtor = &_dtor;
        //_vFTable_S.virtualOperation__S.pf__errorHandler = &_errorHandler;



        /*
         * @todo TODO assign (default) virtual BASEclass function here.
         * Third assign the default base class methods to the vFTable.
         * Or do it in the static initializer in the top of this file.
         */
        //_vFTable_S.virtualOperation__S.pf__uartSend = &_send_uart1;
        //_vFTable_S.virtualOperation__S.pf__uartReceive = &_receive_uart1;




        //END*******TODO******************TODO******************TODO


    }
}



/* -------- END PART: APPLICATION functions ----------------------------------*/





/*******************************************************************************
 **     Function PROTECTED implementation (extern)
 ******************************************************************************/



PROTECTED uart__vFTable__st * _uart__getPt_vFTable(void)
{
    return &_vFTable_S;

}





/*******************************************************************************
 **     Function PUBLIC implementation (extern)
 ******************************************************************************/



EXTERN uart__this__st * uart__new(
         uart__this__st *const ps__this,
         uart__ctorParamList__st *const ps__paramList)
{

     uart__this__st * ps__ret = NULLp;

    if (NULLp != ps__this) {

        ps__ret = ps__this;

    }
#if defined __USE_HEAP__
    else {

        /**
         * Allocate a memory area if object should be stored in the heap
         * heap segment. Alternative the objects can be pushed on the
         * stack or stored in the datasegment.
         */
        ps__ret = (uart__this__st*)malloc(sizeof(
                    uart__this__st));

    }
#endif


    if (NULLp != ps__ret) {

        /**
         * First clear the memory area for this new object.
         */
        memset(ps__ret, 0x00, sizeof(uart__this__st));


        /**
         * Second init the new object data by calling this _ctor
         * explicit. (_ctor can not be overwritten yet).
         */
        _ctor(ps__ret, ps__paramList);


        /**
         * Finally increment the number of active instances
         */
        _activeInstanceCounter++;

    }
    else{
        __MI_OOC__ERROR_HANDLER__NULL_POINTER__
     }

    return ps__ret;
}





EXTERN void uart__deleate(uart__this__st *const ps__this)
{

    if(NULLp != ps__this) {


        if(NULLp != ps__this->ps__virtualOperation->pf__dtor) {

            /**
             * First deconstruct the object members
             */
            ps__this->ps__virtualOperation->pf__dtor(ps__this);

        }
        else{

            _dtor(ps__this);

        }


        #if defined __USE_HEAP__
        /**
         * Afterwards free the objects memory.
         * If you allocate memory in HEAP, this is step is important
         * to prevent a heap overflow and corrupt stack data,
         */
        free(ps__this);
        #endif


        /**
         * Finally decrement the number of active instances
         */
         _activeInstanceCounter--;
    }
    else{

        __MI_OOC__ERROR_HANDLER__NULL_POINTER__

    }
}





EXTERN uint8_t uart__get_instanceCounter(
        uart__this__st *const ps__this)
{

    (void)ps__this;
    return _activeInstanceCounter;

}



/* ----- PART: STATIC (Local) Functions --------------------------------------*/

/* -------- END PART: STATIC (Local) Functions -------------------------------*/



/* ----- PART: EXTERN (Global) Functions -------------------------------------*/

/* -------- END PART: EXTERN (Global) Functions ------------------------------*/



/**************** (C) COPYRIGHT Marco Israel ****** END OF FILE ***************/


